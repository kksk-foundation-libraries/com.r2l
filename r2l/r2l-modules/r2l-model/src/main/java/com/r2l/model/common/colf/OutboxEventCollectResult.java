package com.r2l.model.common.colf;


// Code generated by colf(1); DO NOT EDIT.


import static java.lang.String.format;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.util.InputMismatchException;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;


/**
 * Data bean with built-in serialization support.

 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
@javax.annotation.Generated(value="colf(1)", comments="Colfer from schema file colfer.colf")
public class OutboxEventCollectResult extends com.r2l.model.ColferObject implements Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;




	public String markPoint;

	public String transactionId;

	public String maxEventId;

	public int maxSerialNo;

	public String eventId;

	public int serialNo;

	public String eventTarget;

	public byte action;


	/** Default constructor */
	public OutboxEventCollectResult() {
		init();
	}


	/** Colfer zero values. */
	private void init() {
		markPoint = "";
		transactionId = "";
		maxEventId = "";
		eventId = "";
		eventTarget = "";
	}

	/**
	 * {@link #reset(InputStream) Reusable} deserialization of Colfer streams.
	 */
	public static class Unmarshaller {

		/** The data source. */
		protected InputStream in;

		/** The read buffer. */
		public byte[] buf;

		/** The {@link #buf buffer}'s data start index, inclusive. */
		protected int offset;

		/** The {@link #buf buffer}'s data end index, exclusive. */
		protected int i;


		/**
		 * @param in the data source or {@code null}.
		 * @param buf the initial buffer or {@code null}.
		 */
		public Unmarshaller(InputStream in, byte[] buf) {
			// TODO: better size estimation
			if (buf == null || buf.length == 0)
				buf = new byte[Math.min(OutboxEventCollectResult.colferSizeMax, 2048)];
			this.buf = buf;
			reset(in);
		}

		/**
		 * Reuses the marshaller.
		 * @param in the data source or {@code null}.
		 * @throws IllegalStateException on pending data.
		 */
		public void reset(InputStream in) {
			if (this.i != this.offset) throw new IllegalStateException("colfer: pending data");
			this.in = in;
			this.offset = 0;
			this.i = 0;
		}

		/**
		 * Deserializes the following object.
		 * @return the result or {@code null} when EOF.
		 * @throws IOException from the input stream.
		 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
		 * @throws InputMismatchException when the data does not match this object's schema.
		 */
		public OutboxEventCollectResult next() throws IOException {
			if (in == null) return null;

			while (true) {
				if (this.i > this.offset) {
					try {
						OutboxEventCollectResult o = new OutboxEventCollectResult();
						this.offset = o.unmarshal(this.buf, this.offset, this.i);
						return o;
					} catch (BufferUnderflowException e) {
					}
				}
				// not enough data

				if (this.i <= this.offset) {
					this.offset = 0;
					this.i = 0;
				} else if (i == buf.length) {
					byte[] src = this.buf;
					// TODO: better size estimation
					if (offset == 0) this.buf = new byte[Math.min(OutboxEventCollectResult.colferSizeMax, this.buf.length * 4)];
					System.arraycopy(src, this.offset, this.buf, 0, this.i - this.offset);
					this.i -= this.offset;
					this.offset = 0;
				}
				assert this.i < this.buf.length;

				int n = in.read(buf, i, buf.length - i);
				if (n < 0) {
					if (this.i > this.offset)
						throw new InputMismatchException("colfer: pending data with EOF");
					return null;
				}
				assert n > 0;
				i += n;
			}
		}

	}


	/**
	 * Serializes the object.
	 * @param out the data destination.
	 * @param buf the initial buffer or {@code null}.
	 * @return the final buffer. When the serial fits into {@code buf} then the return is {@code buf}.
	 *  Otherwise the return is a new buffer, large enough to hold the whole serial.
	 * @throws IOException from {@code out}.
	 * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
	 */
	public byte[] marshal(OutputStream out, byte[] buf) throws IOException {
		// TODO: better size estimation
		if (buf == null || buf.length == 0)
			buf = new byte[Math.min(OutboxEventCollectResult.colferSizeMax, 2048)];

		while (true) {
			int i;
			try {
				i = marshal(buf, 0);
			} catch (BufferOverflowException e) {
				buf = new byte[Math.min(OutboxEventCollectResult.colferSizeMax, buf.length * 4)];
				continue;
			}

			out.write(buf, 0, i);
			return buf;
		}
	}

	/**
	 * Serializes the object.
	 * @param buf the data destination.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferOverflowException when {@code buf} is too small.
	 * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
	 */
	public int marshal(byte[] buf, int offset) {
		int i = offset;

		try {
			if (! this.markPoint.isEmpty()) {
				buf[i++] = (byte) 0;
				int start = ++i;

				String s = this.markPoint;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > OutboxEventCollectResult.colferSizeMax)
					throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.markPoint size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.transactionId.isEmpty()) {
				buf[i++] = (byte) 1;
				int start = ++i;

				String s = this.transactionId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > OutboxEventCollectResult.colferSizeMax)
					throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.transactionId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.maxEventId.isEmpty()) {
				buf[i++] = (byte) 2;
				int start = ++i;

				String s = this.maxEventId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > OutboxEventCollectResult.colferSizeMax)
					throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.maxEventId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (this.maxSerialNo != 0) {
				int x = this.maxSerialNo;
				if ((x & ~((1 << 21) - 1)) != 0) {
					buf[i++] = (byte) (3 | 0x80);
					buf[i++] = (byte) (x >>> 24);
					buf[i++] = (byte) (x >>> 16);
					buf[i++] = (byte) (x >>> 8);
				} else {
					buf[i++] = (byte) 3;
					while (x > 0x7f) {
						buf[i++] = (byte) (x | 0x80);
						x >>>= 7;
					}
				}
				buf[i++] = (byte) x;
			}

			if (! this.eventId.isEmpty()) {
				buf[i++] = (byte) 4;
				int start = ++i;

				String s = this.eventId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > OutboxEventCollectResult.colferSizeMax)
					throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.eventId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (this.serialNo != 0) {
				int x = this.serialNo;
				if ((x & ~((1 << 21) - 1)) != 0) {
					buf[i++] = (byte) (5 | 0x80);
					buf[i++] = (byte) (x >>> 24);
					buf[i++] = (byte) (x >>> 16);
					buf[i++] = (byte) (x >>> 8);
				} else {
					buf[i++] = (byte) 5;
					while (x > 0x7f) {
						buf[i++] = (byte) (x | 0x80);
						x >>>= 7;
					}
				}
				buf[i++] = (byte) x;
			}

			if (! this.eventTarget.isEmpty()) {
				buf[i++] = (byte) 6;
				int start = ++i;

				String s = this.eventTarget;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > OutboxEventCollectResult.colferSizeMax)
					throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.eventTarget size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (this.action != 0) {
				buf[i++] = (byte) 7;
				buf[i++] = this.action;
			}

			buf[i++] = (byte) 0x7f;
			return i;
		} catch (ArrayIndexOutOfBoundsException e) {
			if (i - offset > OutboxEventCollectResult.colferSizeMax)
				throw new IllegalStateException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult exceeds %d bytes", OutboxEventCollectResult.colferSizeMax));
			if (i > buf.length) throw new BufferOverflowException();
			throw e;
		}
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset) {
		return unmarshal(buf, offset, buf.length);
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @param end the index limit for {@code buf}, exclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset, int end) {
		if (end > buf.length) end = buf.length;
		int i = offset;

		try {
			byte header = buf[i++];

			if (header == (byte) 0) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size < 0 || size > OutboxEventCollectResult.colferSizeMax)
					throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.markPoint size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int start = i;
				i += size;
				this.markPoint = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 1) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size < 0 || size > OutboxEventCollectResult.colferSizeMax)
					throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.transactionId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int start = i;
				i += size;
				this.transactionId = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 2) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size < 0 || size > OutboxEventCollectResult.colferSizeMax)
					throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.maxEventId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int start = i;
				i += size;
				this.maxEventId = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 3) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.maxSerialNo = x;
				header = buf[i++];
			} else if (header == (byte) (3 | 0x80)) {
				this.maxSerialNo = (buf[i++] & 0xff) << 24 | (buf[i++] & 0xff) << 16 | (buf[i++] & 0xff) << 8 | (buf[i++] & 0xff);
				header = buf[i++];
			}

			if (header == (byte) 4) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size < 0 || size > OutboxEventCollectResult.colferSizeMax)
					throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.eventId size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int start = i;
				i += size;
				this.eventId = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 5) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.serialNo = x;
				header = buf[i++];
			} else if (header == (byte) (5 | 0x80)) {
				this.serialNo = (buf[i++] & 0xff) << 24 | (buf[i++] & 0xff) << 16 | (buf[i++] & 0xff) << 8 | (buf[i++] & 0xff);
				header = buf[i++];
			}

			if (header == (byte) 6) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size < 0 || size > OutboxEventCollectResult.colferSizeMax)
					throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult.eventTarget size %d exceeds %d UTF-8 bytes", size, OutboxEventCollectResult.colferSizeMax));

				int start = i;
				i += size;
				this.eventTarget = new String(buf, start, size, StandardCharsets.UTF_8);
				header = buf[i++];
			}

			if (header == (byte) 7) {
				this.action = buf[i++];
				header = buf[i++];
			}

			if (header != (byte) 0x7f)
				throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
		} finally {
			if (i > end && end - offset < OutboxEventCollectResult.colferSizeMax) throw new BufferUnderflowException();
			if (i < 0 || i - offset > OutboxEventCollectResult.colferSizeMax)
				throw new SecurityException(format("colfer: com/r2l/model/common/colf.OutboxEventCollectResult exceeds %d bytes", OutboxEventCollectResult.colferSizeMax));
			if (i > end) throw new BufferUnderflowException();
		}

		return i;
	}

	// {@link Serializable} version number.
	private static final long serialVersionUID = 8L;

	// {@link Serializable} Colfer extension.
	private void writeObject(ObjectOutputStream out) throws IOException {
		// TODO: better size estimation
		byte[] buf = new byte[1024];
		int n;
		while (true) try {
			n = marshal(buf, 0);
			break;
		} catch (BufferUnderflowException e) {
			buf = new byte[4 * buf.length];
		}

		out.writeInt(n);
		out.write(buf, 0, n);
	}

	// {@link Serializable} Colfer extension.
	private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
		init();

		int n = in.readInt();
		byte[] buf = new byte[n];
		in.readFully(buf);
		unmarshal(buf, 0);
	}

	// {@link Serializable} Colfer extension.
	private void readObjectNoData() throws ObjectStreamException {
		init();
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.markPoint.
	 * @return the value.
	 */
	public String getMarkPoint() {
		return this.markPoint;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.markPoint.
	 * @param value the replacement.
	 */
	public void setMarkPoint(String value) {
		this.markPoint = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.markPoint.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withMarkPoint(String value) {
		this.markPoint = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.transactionId.
	 * @return the value.
	 */
	public String getTransactionId() {
		return this.transactionId;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.transactionId.
	 * @param value the replacement.
	 */
	public void setTransactionId(String value) {
		this.transactionId = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.transactionId.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withTransactionId(String value) {
		this.transactionId = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.maxEventId.
	 * @return the value.
	 */
	public String getMaxEventId() {
		return this.maxEventId;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.maxEventId.
	 * @param value the replacement.
	 */
	public void setMaxEventId(String value) {
		this.maxEventId = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.maxEventId.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withMaxEventId(String value) {
		this.maxEventId = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.maxSerialNo.
	 * @return the value.
	 */
	public int getMaxSerialNo() {
		return this.maxSerialNo;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.maxSerialNo.
	 * @param value the replacement.
	 */
	public void setMaxSerialNo(int value) {
		this.maxSerialNo = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.maxSerialNo.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withMaxSerialNo(int value) {
		this.maxSerialNo = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.eventId.
	 * @return the value.
	 */
	public String getEventId() {
		return this.eventId;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.eventId.
	 * @param value the replacement.
	 */
	public void setEventId(String value) {
		this.eventId = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.eventId.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withEventId(String value) {
		this.eventId = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.serialNo.
	 * @return the value.
	 */
	public int getSerialNo() {
		return this.serialNo;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.serialNo.
	 * @param value the replacement.
	 */
	public void setSerialNo(int value) {
		this.serialNo = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.serialNo.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withSerialNo(int value) {
		this.serialNo = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.eventTarget.
	 * @return the value.
	 */
	public String getEventTarget() {
		return this.eventTarget;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.eventTarget.
	 * @param value the replacement.
	 */
	public void setEventTarget(String value) {
		this.eventTarget = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.eventTarget.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withEventTarget(String value) {
		this.eventTarget = value;
		return this;
	}

	/**
	 * Gets com/r2l/model/common/colf.OutboxEventCollectResult.action.
	 * @return the value.
	 */
	public byte getAction() {
		return this.action;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.action.
	 * @param value the replacement.
	 */
	public void setAction(byte value) {
		this.action = value;
	}

	/**
	 * Sets com/r2l/model/common/colf.OutboxEventCollectResult.action.
	 * @param value the replacement.
	 * @return {link this}.
	 */
	public OutboxEventCollectResult withAction(byte value) {
		this.action = value;
		return this;
	}

	@Override
	public final int hashCode() {
		int h = 1;
		if (this.markPoint != null) h = 31 * h + this.markPoint.hashCode();
		if (this.transactionId != null) h = 31 * h + this.transactionId.hashCode();
		if (this.maxEventId != null) h = 31 * h + this.maxEventId.hashCode();
		h = 31 * h + this.maxSerialNo;
		if (this.eventId != null) h = 31 * h + this.eventId.hashCode();
		h = 31 * h + this.serialNo;
		if (this.eventTarget != null) h = 31 * h + this.eventTarget.hashCode();
		h = 31 * h + (this.action & 0xff);
		return h;
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof OutboxEventCollectResult && equals((OutboxEventCollectResult) o);
	}

	public final boolean equals(OutboxEventCollectResult o) {
		if (o == null) return false;
		if (o == this) return true;
		return o.getClass() == OutboxEventCollectResult.class
			&& (this.markPoint == null ? o.markPoint == null : this.markPoint.equals(o.markPoint))
			&& (this.transactionId == null ? o.transactionId == null : this.transactionId.equals(o.transactionId))
			&& (this.maxEventId == null ? o.maxEventId == null : this.maxEventId.equals(o.maxEventId))
			&& this.maxSerialNo == o.maxSerialNo
			&& (this.eventId == null ? o.eventId == null : this.eventId.equals(o.eventId))
			&& this.serialNo == o.serialNo
			&& (this.eventTarget == null ? o.eventTarget == null : this.eventTarget.equals(o.eventTarget))
			&& this.action == o.action;
	}

}
